/*
 * Blocks for syntax directed translation.
 *
 * INTERFACES:
 *    a1of2: dual-rail data channel
 *    a1of1: single-rail control channel
 *    dualrail: one-bit of data
 */

import "~/Documents/ADCO/act/globals.act";
import "~/Documents/ADCO/act/channel.act";

/* ============================ CIRCUIT ELEMENTS ============================ */

/* DUALRAIL AND GATE */
defproc syn_expr_and (dualrail in1, in2; dualrail out)
{
  _dualrail _out;
  prs {
    in1.t & in2.t -> _out.t-
    ~in1.t & ~in2.t -> _out.t+
    in1.f & (in2.t | in2.f) | in1.t & in2.f -> _out.f-
    ~in1.t & ~in1.f & ~in2.t & ~in2.f -> _out.f+

    _out.t => out.t-
    _out.f => out.f-
  }
}

/* DUALRAIL OR GATE */
defproc syn_expr_or (dualrail in1, in2; dualrail out)
{
  _dualrail _out;
  prs {
    in1.t & (in2.t|in2.f) | in1.f & in2.t -> _out.t-
    ~in1.t & ~in1.f & ~in2.t & ~in2.f -> _out.t+
    in1.f & in2.f -> _out.f-
    ~in1.f & ~in2.f -> _out.f+

    _out.t => out.t-
    _out.f => out.f-
  }
}

/* BOOLEAN OR GATE */
defproc syn_or2 (bool x, y, out)
{
  bool _or;
  prs {
    x | y => _or-
    _or => out-
  }
}

/* BOOLEAN NAND GATE */
defproc syn_notand (bool x, y, out)
{
  bool _inv;
  prs {
    x => _inv-
    _inv | y => out-
  }
}

/* DUALRAIL NOT GATE */
defproc syn_expr_not (dualrail in; dualrail out)
{
  out.t = in.f;
  out.f = in.t;
}

/* FULL ADDER */
defproc syn_full_adder (dualrail a, b, c_in; dualrail s, c_out)
{
  _dualrail _s;
  _dualrail _c_out;
  prs {
    (a.t & b.t & c_in.t) | (a.t & b.f & c_in.f) | (a.f & b.t & c_in.f) | (a.f & b.f & c_in.t) => _s.t-
  	(a.f & b.f & c_in.f) | (a.t & b.t & c_in.f) | (a.f & b.t & c_in.t) | (a.t & b.f & c_in.t) => _s.f-

  	(a.t & b.t) | (a.t & c_in.t) | (b.t & c_in.t) => _c_out.t-
  	(a.f & b.f) | (a.f & c_in.f) | (b.f & c_in.f) => _c_out.f-

  	_s.t => s.t-
  	_s.f => s.f-
  	_c_out.t => c_out.t-
  	_c_out.f => c_out.f-
  }
}

/* MULTIPLICATION CELL */
template<pint N>
defproc syn_mul_cell (dualrail in1[N], in2; dualrail out[N])
{
  syn_expr_and and[N];
  (i:N: and[i].in1 = in1[i];
        and[i].in2 = in2;
        and[i].out = out[i];)
}

/* MUX CELL */
defproc syn_mux (dualrail a, b, s; dualrail o)
{
  _dualrail _s, _o;
  prs {
    s.f & a.t -> _o.t-
    s.f & a.f -> _o.f-
    s.t & b.t -> _o.t-
    s.t & b.f -> _o.f-

    ~_s.f & ~a.t & ~a.f -> _o.t+
    ~_s.f & ~a.t & ~a.f -> _o.f+
    ~_s.t & ~b.t & ~b.f -> _o.t+
    ~_s.t & ~b.t & ~b.f -> _o.f+
    ~s.t & ~s.f -> o.t-
    ~s.t & ~s.f -> o.f-

    _s.t => s.t-
    _s.f => s.f-
    _o.t => o.t-
    _o.f => o.f-
  }
}

/* 2:1 MUX */
template<pint N>
defproc syn_2_to_1_mux (dualrail a[N], b[N], s; dualrail o[N])
{
  syn_mux mux[N];
  (i:N: mux[i].a = a[i];
        mux[i].b = b[i];
        mux[i].s = s;
        mux[i].o = o[i];)
}

/* ========================== MISCELLANEOUS BLOCKS ========================== */

/* CARRY-SAVE ADDER */
template<pint N>
defproc syn_carry_save_adder (dualrail in1[N], in2[N], in3[N]; dualrail out1[N], out2[N])
{
  syn_full_adder add[N];
  (i:N: add[i].a = in1[i];
        add[i].b = in2[i];
        add[i].c_in = in3[i];
        add[i].s = out1[i];
        add[i].c_out = out2[i];)
}

/* 4:2 COMPRESSOR */
template<pint N>
defproc syn_4_to_2_compressor (dualrail in1[N], in2[N], in3[N], in4[N]; dualrail out1[N], out2[N])
{
  dualrail csa_out1[N], csa_out2[N];
  syn_carry_save_adder<N> csa1 (in1, in2, in3, csa_out1, csa_out2);
  syn_carry_save_adder<N> csa2 (in4, csa_out1, csa_out2, out1, out2);
}

/* ======================== VARIABLE INITIALIZATION ======================== */

/* TRUE */
defproc syn_var_init_true (dualrail v)
{
  prs {
    Reset -> v.f-
    v.f<8> -> v.t-
    v.t<8> -> v.f-
    [weak=1] ~v.t<4,4> -> v.f+
    [weak=1] ~v.f<4,4> -> v.t+
  }
}

/* FALSE */
defproc syn_var_init_false (dualrail v)
{
  prs {
    Reset -> v.t-
    v.f<8> -> v.t-
    v.t<8> -> v.f-
    [weak=1] ~v.t<4,4> -> v.f+
    [weak=1] ~v.f<4,4> -> v.t+
  }
}

/* ================================= TREES ================================= */

template<pint N> defproc syn_invctree (bool in[N]; bool _out);
template<pint N> defproc syn_ctree (bool in[N]; bool out);

/* INVERTING COMPLETION TREE */
template<pint N>
defproc syn_invctree (bool in[N]; bool _out)
{
  [  N > 3 ->
     syn_ctree<N/2> l(in[0..N/2-1]);
     syn_ctree<N-N/2> r(in[N/2..N-1]);
     prs {
       l.out & r.out -> _out-
       ~l.out & ~r.out -> _out+
     }
  [] else ->
     prs {
      (&i:N:in[i]) -> _out-
      (&i:N:~in[i]) -> _out+
     }
  ]
}

/* COMPLETION TREE */
template<pint N>
defproc syn_ctree (bool in[N]; bool out)
{
  [  N > 3 ->
     syn_invctree<N/2> l(in[0..N/2-1]);
     syn_invctree<N-N/2> r(in[N/2..N-1]);
     prs {
       l._out & r._out -> out-
       ~l._out & ~r._out -> out+
     }
  [] N = 1 -> out = in[0];
  [] else ->
      bool _out;
      prs {
        (&i:N:in[i]) -> _out-
      	(&i:N:~in[i]) -> _out+
        _out => out-
      }
  ]
}

/* LINEAR CSA CASCADE */
template<pint M, N>
defproc syn_linear_csa_cascade (dualrail in[M][N]; dualrail out1[N], out2[N])
{
  [  M > 3 ->
      dualrail next[M-1][N];
      syn_carry_save_adder<N> cs (in[0][0..N-1], in[1][0..N-1], in[2][0..N-1], next[0][0..N-1], next[1][0..N-1]);
      (i:M-3: next[i+2][0..N-1] = in[i+3][0..N-1];)
      syn_linear_csa_cascade<M-1, N> csac (next, out1, out2);
  [] M = 1 ->
      syn_var_init_false const_0;
      out1 = in[0][0..N-1];
      (i:N: out2[i] = const_0.v;)
  [] M = 2 ->
      out1 = in[0][0..N-1];
      out2 = in[1][0..N-1];
  [] else ->
      syn_carry_save_adder<N> cs_3 (in[0][0..N-1], in[1][0..N-1], in[2][0..N-1], out1, out2);
  ]
}

/* WALLACE TREE */
template<pint M, N>
defproc syn_wallace_tree (dualrail in[M][N]; dualrail out1[N], out2[N])
{
  [  M > 4 ->
      syn_wallace_tree<M/2, N> l(in[0..M/2-1][0..N-1]);
      syn_wallace_tree<M-M/2, N> r(in[M/2..M-1][0..N-1]);
      syn_4_to_2_compressor<N> comp (l.out1, l.out2, r.out1, r.out2, out1, out2);
  [] M = 1 ->
      syn_var_init_false const_0;
      out1 = in[0][0..N-1];
      (i:N: out2[i] = const_0.v;)
  [] M = 2 ->
      out1 = in[0][0..N-1];
      out2 = in[1][0..N-1];
  [] M = 3 ->
      syn_carry_save_adder<N> cs_3 (in[0][0..N-1], in[1][0..N-1], in[2][0..N-1], out1, out2);
  [] else ->
      syn_4_to_2_compressor<N> comp_4 (in[0][0..N-1], in[1][0..N-1], in[2][0..N-1], in[3][0..N-1], out1, out2);
  ]
}

/* ============================= COMMUNICATION ============================= */

/* RECV */
defproc syn_recv (a1of1 go; dualrail v; a1of2 in)
{
  bool _goa;
  go.a = in.a;
  prs {
    [keeper=0] go.r & _goa & in.t -> v.f-
    [keeper=0] go.r & _goa & in.f -> v.t-
    go.r & (v.t & in.t | v.f & in.f) -> _goa-
    ~in.t & ~in.f & ~go.r -> _goa+
    Reset|_goa => go.a-
  }
}

/* ========================= EXPRESSION EVALUATION ========================= */

/* SINGLE-BIT VARIABLE */
defproc syn_expr_var (bool go_r; dualrail v; dualrail out)
{
  _dualrail _out;
  prs {
    go_r & v.t -> _out.t-
    go_r & v.f -> _out.f-
    ~_Reset | ~go_r -> _out.t+
    ~_Reset | ~go_r -> _out.f+

    _out.t => out.t-
    _out.f => out.f-
  }
}

/* MULTI-BIT VARIABLE */
template<pint N>
defproc syn_expr_vararray (bool go_r; dualrail v[N]; dualrail out[N])
{
  syn_expr_var ev[N];
  (i:N: ev[i].go_r = go_r;
        ev[i].v = v[i];
        ev[i].out = out[i];)
}

/* ========================= ARITHMETIC OPERATIONS ========================= */

/* ADDITION */
template<pint N>
defproc syn_add (dualrail in1[N], in2[N], c_in; dualrail out[N], c_out)
{
  syn_full_adder add[N];

  (i:N: add[i].a = in1[i];
        add[i].b = in2[i];
        add[i].s = out[i];)

  add[0].c_in = c_in;
  c_out = add[N-1].c_out;
  (i:N-1: add[i+1].c_in = add[i].c_out;)
}

/* UNARY MINUS */
template<pint N>
defproc syn_uminus (dualrail v[N]; dualrail out[N])
{
  dualrail inv[N];
  (i:N: v[i].t = inv[i].f;
        v[i].f = inv[i].t;)

  syn_var_init_false f[N];
  dualrail zero[N];
  (i:N: zero[i] = f[i].v;)

  syn_var_init_true const_1;
  syn_add<N> r (inv, zero, const_1.v, out);
}

/* SUBTRACTION */
template<pint N>
defproc syn_sub (dualrail in1[N], in2[N]; dualrail out[N], c_out)
{
  dualrail _in2[N];
  syn_uminus<N> u (in2, _in2);
  syn_var_init_false const_0;
  syn_add<N> s (in1, _in2, const_0.v, out, c_out);
}

/* UNSIGNED MULTIPLICATION */
template<pint N>
defproc syn_mul (dualrail in1[N], in2[N]; dualrail out[N], overflow)
{
  syn_var_init_false const_0;
  dualrail partial_products[N][N];

  syn_mul_cell<N> mul[N];
  (i:N: mul[i].in1 = in1;
        mul[i].in2 = in2[i];
        (j:i: partial_products[i][j] = const_0.v;)
        (j:N-i: partial_products[i][j+i] = mul[i].out[j];))

  syn_wallace_tree<N, N> wal (partial_products);

  syn_add<N> add (wal.out1, wal.out2, const_0.v, out, overflow);
}

/* SIGNED MULTIPLICATION
template<pint N>
defproc syn_mul (dualrail in1[N], in2[N]; dualrail out[N], overflow)
{
  [  in1[N-1].t & in2[N-1].t ->
      dualrail _in1[N], _in2[N];
      syn_uminus<N> um_1 (in1, _in1);
      syn_uminus<N> um_2 (in2, _in2);
      syn_unsigned_mul<N> mul_1 (_in1, _in2, out, overflow);
  [] in1[N-1].t ->
      dualrail _in1[N], _out[N];
      syn_uminus<N> um_3 (in1, _in1);
      syn_unsigned_mul<N> mul_2 (_in1, in2, _out, overflow);
      syn_uminus<N> um_4 (_out, out);
  [] in2[N-1].t ->
      dualrail _in2[N], _out[N];
      syn_uminus<N> um_5 (in2, _in2);
      syn_unsigned_mul<N> mul_3 (in1, _in2, _out, overflow);
      syn_uminus<N> um_6 (_out, out);
  [] else ->
      syn_unsigned_mul<N> mul_4 (in1, in2, out, overflow);
  ]
}
*/

/*
template<pint N>
defproc syn_mul (dualrail in1[N], in2[N]; dualrail out[N], overflow)
{
  dualrail _in1[N], _in2[N], _out[N];
  dualrail s1, s2, so;
  _dualrail _s1, _s2, _so;

  syn_uminus<N> u1 (in1, _in1);
  syn_uminus<N> u2 (in2, _in2);

  syn_unsigned_mul<N> mul;
  mul.overflow = overflow;

  syn_2_to_1_mux<N> mux1 (in1, _in1, s1, mul.in1);
  syn_2_to_1_mux<N> mux2 (in2, _in2, s2, mul.in2);

  syn_uminus<N> uo (mul.out, _out);

  syn_2_to_1_mux<N> muxo (mul.out, _out, so, out);

  prs {
    in1[N-1].f -> s1.t-
    in1[N-1].f -> _s1.f-
    in1[N-1].t -> s1.f-
    in1[N-1].t -> _s1.t-

    in2[N-1].f -> s2.t-
    in2[N-1].f -> _s2.f-
    in2[N-1].t -> s2.f-
    in2[N-1].t -> _s2.t-

    ~in1[N-1].f & ~in1[N-1].t -> _s1+
    ~in2[N-1].f & ~in2[N-1].t -> _s2+

    s1 & s2 => _so-

    _s1.t => s1.t-
    _s1.f => s1.f-
    _s2.t => s2.t-
    _s2.f => s2.f-
    _so.t => so.t-
    _so.f => so.f-
  }
}
*/

/* LEFT-SHIFT */
template<pint S, N>
defproc syn_shift_left (dualrail in[N]; dualrail out[N])
{
  syn_var_init_false const_0;
  (i:S: out[S] = const_0.v;)
  (i:N-S: out[i+S] = in[i];)
}

/*
template<pint M, N>
defproc syn_shift_left (dualrail in[N], sa[M]; dualrail out[N])
{
  syn_var_init_false const_0;
  syn_mux muxes[M][N];
  (i:M: (j:N: muxes[i][j].s = sa[i].t;))
  (j:N: muxes[0][j].a = in[j];)
  (i:M-1: (j:N: muxes[i+1][j].in = muxes[i][j].out;))
  (j:N: muxes[M-1][j].out = out[j];)

  muxes[0][0] = const_0.v;
  (j:N-1: muxes[0][j+1].b = in[j];)
  (i:M-1: (j:N: muxes[i+1][j].b = muxes[i][j].out;))
}
*/

/* =========================== BOOLEAN OPERATIONS =========================== */

/* BITWISE AND */
template<pint N>
defproc syn_and (dualrail in1[N], in2[N]; dualrail out[N])
{
  syn_expr_and and[N];
  (i:N: and[i].in1 = in1[N];
        and[i].in2 = in2[N];
        and[i].out = out[N];)
}

/* BITWISE OR */
template<pint N>
defproc syn_or (dualrail in1[N], in2[N]; dualrail out[N])
{
  syn_expr_or or[N];
  (i:N: or[i].in1 = in1[N];
        or[i].in2 = in2[N];
        or[i].out = out[N];)
}

/* BITWISE COMPLEMENT */
template<pint N>
defproc syn_not (dualrail in[N]; dualrail out[N])
{
  syn_expr_not not[N];
  (i:N: not[i].in = in[i]; not[i].out = out[i];)
}

/* ============================ CHP CONSTRUCTS ============================ */

/* SKIP */
defproc syn_skip (a1of1 go)
{
  go.r = go.a;
}

/* SIMPLE FULL SEQUENCER */
defproc syn_fullseq (a1of1 go; a1of1 r)
{
  bool x;
  bool _gor;
  bool _goa;
  bool _ra;

  prs {
    ~x & ~_gor -> r.r+
    ~_ra -> x+
    Reset | x -> r.r-
    x & _ra -> _goa-
    _gor -> x-
    ~x -> _goa+
    go.r => _gor-
    _goa => go.a-
    r.a => _ra-
  }
}

/* SEQUENTIAL COMPOSITION */
defproc syn_seq (a1of1 go; a1of1 s1, s2)
{
  go.r = s1.r;
  s1.a = s2.r;
  go.a = s2.a;
}

/* PARALLEL COMPOSITION */
defproc syn_par (a1of1 go; a1of1 s1, s2)
{
  go.r = s1.r;
  go.r = s2.r;

  bool _c;

  prs {
    s1.a & s2.a -> _c-
    ~s1.a & ~s2.a -> _c+

    _c => go.a-
  }
}
