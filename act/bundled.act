import "~/Documents/ADCO/act/globals.act";
import "~/Documents/ADCO/act/channel.act";

defproc delaybuf(bool in, out)
{
  bool _x;
  prs {
     in => _x-
     _x => out-
  }
}

template<pint D>
defproc delay (bool in, out)
{
  delaybuf d[D];
  (i:D-1:d[i].out=d[i+1].in;)
  d[0].in = in;
  d[D-1].out = out;
}

defproc bundled_cmp_1 (bool go_r; dualrail c[4]; dualrail out)
{
  /* combinational logic */
  delay<4> d;
  d.in = go_r;

  prs {
    d.out & c[0].t => out.t+
    d.out & c[0].f => out.f+
  }
}

template<pint N>
defproc bundled_add_N (bool go_r; dualrail in1[N], in2[N]; dualrail out[N])
{
  /* combinational logic */
  delay<N-1> d;
  d.in = go_r;

  bool _d_out;
  _dualrail _s[N];

  syn_var_init_false const_0;
  syn_add<N> add_N;
  (i:N: in1[i] = add_N.in1[i];)
  (i:N: in2[i] = add_N.in2[i];)
  add_N.c_in = const_0.v;

  prs {
    (i:N: add_N.out[i].t => _s[i].t-
          add_N.out[i].f => _s[i].f-)

    (i:N: _d_out | _s[i].t => out[i].t-
          _d_out | _s[i].f => out[i].f-)

    d.out => _d_out-
  }
}

template<pint N>
defproc bundled_sub_N (bool go_r; dualrail in1[N], in2[N]; dualrail out[N])
{
  /* combinational logic */
  delay<N-1> d;
  d.in = go_r;

  bool _d_out;
  _dualrail _diff[N];

  syn_sub<N> sub_N;
  (i:N: in1[i] = sub_N.in1[i];)
  (i:N: in2[i] = sub_N.in2[i];)

  prs {
    (i:N: sub_N.out[i].t => _diff[i].t-
          sub_N.out[i].f => _diff[i].f-)

    (i:N: _d_out | _diff[i].t => out[i].t-
          _d_out | _diff[i].f => out[i].f-)

    d.out => _d_out-
  }
}

template<pint N>
defproc bundled_mul_N (bool go_r; dualrail in1[N], in2[N]; dualrail out[N])
{
  /* combinational logic */
  delay<N*N> d;
  d.in = go_r;

  bool _d_out;
  _dualrail _p[N];

  syn_mul<N> mul_N;
  (i:N: in1[i] = mul_N.in1[i];)
  (i:N: in2[i] = mul_N.in2[i];)

  prs {
    (i:N: mul_N.out[i].t => _p[i].t-
          mul_N.out[i].f => _p[i].f-)

    (i:N: _d_out | _p[i].t => out[i].t-
          _d_out | _p[i].f => out[i].f-)

    d.out => _d_out-
  }
}

defproc bundled_fblock_8 (bool go_r; dualrail c[4]; dualrail x[8], y[8]; dualrail out[8])
{
   /* combinational logic */
   delay<4> d;
   d.in = go_r;

   prs {
      (i:8: d.out & x[i].t => out[i].t+
            d.out & x[i].f => out[i].f+)
   }
}
