import "~/Documents/ADCO/act/globals.act";
import "~/Documents/ADCO/act/channel.act";

/* ================================ BUFFERS ================================ */

defproc delaybuf (bool in, out)
{
  bool _x;
  prs {
     in => _x-
     _x => out-
  }
}

template<pint D>
defproc delay (bool in, out)
{
  delaybuf d[D];
  (i:D-1:d[i].out=d[i+1].in;)
  d[0].in = in;
  d[D-1].out = out;
}

/* ============================= COMMUNICATION ============================= */

/* BUNDLED RECV */
template<pint N>
defproc bundled_recv (a1of1 go; dualrail v[N]; aN1of2 in)
{
  delay<N> d;
  d.in = go.r;

  syn_recv rec[N];
  (i:N: rec[i].go.r = go.r;
        rec[i].v = v[i];
        rec[i].in.t = in.d[i].t;
        rec[i].in.f = in.d[i].f;)

  bool _go_a, _in_a;
  prs {
    rec[0].go.a & d.out => _go_a-
    rec[0].in.a & d.out => _in_a-
    _go_a => go.a-
    _in_a => in.a-
  }
}

/* ========================= ARITHMETIC OPERATIONS ========================= */

/* UNARY MINUS */
template<pint N>
defproc bundled_uminus (a1of1 go; dualrail in[N]; dualrail out[N])
{
  delay<2*N> d;
  d.in = go.r;

  syn_uminus<N> uminus (in, out);

  bool _go_a;
  prs {
    d.out => _go_a-
    _go_a => go.a-
  }
}

template<pint N>
defproc bundled_add (a1of1 go; dualrail in1[N], in2[N]; dualrail out[N])
{
  delay<N> d;
  d.in = go.r;

  syn_add<N> add (in1, in2, out);

  bool _go_a;
  prs {
    d.out => _go_a-
    _go_a => go.a-
  }
}

template<pint N>
defproc bundled_sub (a1of1 go; dualrail in1[N], in2[N]; dualrail out[N])
{
  delay<2*N> d;
  d.in = go.r;

  syn_sub<N> sub (in1, in2, out);

  bool _go_a;
  prs {
    d.out => _go_a-
    _go_a => go.a-
  }
}

template<pint N>
defproc bundled_mul (a1of1 go; dualrail in1[N], in2[N]; dualrail out[N])
{
  delay<N*N> d;
  d.in = go.r;

  syn_mul<N> mul (in1, in2, out);

  bool _go_a;
  prs {
    d.out => _go_a-
    _go_a => go.a-
  }
}

/* =========================== BOOLEAN OPERATIONS =========================== */

template<pint N>
defproc bundled_not (a1of1 go; dualrail in[N]; dualrail out[N])
{
  delay<N> d;
  d.in = go.r;

  syn_not<N> not (in, out);

  bool _go_a;
  prs {
    d.out => _go_a-
    _go_a => go.a-
  }
}

template<pint N>
defproc bundled_and (a1of1 go; dualrail in1[N], in2[N]; dualrail out[N])
{
  delay<N> d;
  d.in = go.r;

  syn_and<N> and (in1, in2, out);

  bool _go_a;
  prs {
    d.out => _go_a-
    _go_a => go.a-
  }
}

template<pint N>
defproc bundled_or (a1of1 go; dualrail in1[N], in2[N]; dualrail out[N])
{
  delay<N> d;
  d.in = go.r;

  syn_or<N> or (in1, in2, out);

  bool _go_a;
  prs {
    d.out => _go_a-
    _go_a => go.a-
  }
}

template<pint N>
defproc bundled_xor (a1of1 go; dualrail in1[N], in2[N]; dualrail out[N])
{
  delay<N> d;
  d.in = go.r;

  syn_xor<N> xor (in1, in2, out);

  bool _go_a;
  prs {
    d.out => _go_a-
    _go_a => go.a-
  }
}

/* ================================ SCRATCH ================================ */

defproc bundled_cmp_1 (bool go_r; dualrail c[4]; dualrail out)
{
  /* combinational logic */
  delay<4> d;
  d.in = go_r;

  prs {
    d.out & c[0].t => out.t+
    d.out & c[0].f => out.f+
  }
}

defproc bundled_fblock_8 (bool go_r; dualrail c[4]; dualrail x[8], y[8]; dualrail out[8])
{
   /* combinational logic */
   delay<4> d;
   d.in = go_r;

   prs {
      (i:8: d.out & x[i].t => out[i].t+
            d.out & x[i].f => out[i].f+)
   }
}
